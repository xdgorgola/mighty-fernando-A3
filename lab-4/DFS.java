import java.util.LinkedList;

/**
 * Class that applies DFS with keeping predecesors, ordinals, and trees.
 */
public class DFS {
    /**
     * Graph in which is going to be used DFS
     */
    private Grafo grafo;
    /**
     * Path in preorder.
     */
    private LinkedList<Integer> path;
    /**
     * Int that saves the order on which a node is discovered.
     */
    private int ord;
    /**
     * String that saves the tree of the given graph generated by DFS.
     */
    private String arb;
    /**
     * Helper to print arb. It implies depth.
     */
    private StringBuilder tab;
    /**
     * Value of trunc given by the user.
     */
    private int trunc;

    public DFS(Grafo grafo) {
        this.grafo = grafo;
        tab = new StringBuilder();
        trunc = 0;
        ord = 0;
        arb = "";
        path = new LinkedList<Integer>();
    }

    /**
     * Loads a graph from a file and use DFS on it.
     * 
     * @param grafo Graph to apply DFS.
     */
    public void DFSForest(int vertex) {
        tab.append("    ");
        if (grafo.GetNode(0) != null) {
            grafo.GetNode(0).SetImmediatePred(0);
            arb += vertex + "-" + vertex + "(raiz)";
            arb += "\n";
            DFSVisited(vertex);
        }
    }

    /**
     * Start to run DFS recursively since node with u as identifier. It does save
     * the path of DFS. It could trunc that path if it is requested.
     * 
     * @param u source node.
     */
    public void DFSVisited(int u) {
        LLNode node = grafo.GetNode(u);
        node.SetOrd(ord);
        ord++;
        node.SetColor(1);
        if (trunc <= 0 || path.size() < trunc) {
            path.add(u);
            tab.append("   ");
            for (int v : node.GetSucesors()) {
                LLNode suce = grafo.GetNode(v);
                if (suce.GetColor() == 0) {
                    suce.SetImmediatePred(u);
                    arb += tab.toString() + u + "-" + v + " (es camino)";
                    arb += "\n";
                    DFSVisited(v);
                } else {
                    if (u != 0) {
                        arb += tab.toString() + u + "-" + v + " (camino subida)";
                    } else {
                        arb += u + "-" + v + " (camino cruzado)";
                    }
                    arb += "\n";
                }
            }
            node.SetColor(2);
            tab.delete(tab.length() - 4, tab.length() - 1);
        }
    }

    /**
     * Modifies value of trunc if it is asked by the user.
     * 
     * @param int with new value.
     */
    public void SetTrunc(int trunc) {
        this.trunc = trunc;
    }

    /**
     * It returns path generated by DFS.
     * 
     * @return LinkedList<Integer> with the path.
     */
    public LinkedList<Integer> GetPath() {
        return path;
    }

    /**
     * It does always print the elements that aren't reacheable.
     * 
     * @param arbo boolean that defines if it should print tree generated by DFS.
     * @param ordi boolean that defines if it should print ordinals of the vertex.
     * @param pred boolean that defines if it should print immediate predecesors of
     *             the vertex on DFS.
     */
    public void DFSConnected(boolean arbo, boolean ordi, boolean pred) {
        String noAlcanzables = "";
        for (int vertex : grafo.Vertices()) {
            if (grafo.GetNode(vertex).GetImmediatePred() == -1) {
                noAlcanzables += vertex + " ";
            }
        }
        System.out.println(noAlcanzables);
        if (arbo) {
            System.out.println("Arborescencia: ");
            System.out.println(arb);
        }
        if (ordi) {
            System.out.println("Ordinales ");
            for (int vertex : grafo.Vertices()) {
                System.out.println(vertex + ": " + grafo.GetNode(vertex).GetOrd());
            }
        }
        if (pred) {
            System.out.println("Predecesores ");
            for (int vertex : grafo.Vertices()) {
                System.out.println(vertex + ": " + grafo.GetNode(vertex).GetImmediatePred());
            }
        }
    }
}